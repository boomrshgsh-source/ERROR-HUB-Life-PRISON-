local WEBHOOK_URL = "https://canary.discord.com/api/webhooks/1440700806495080511/GX8AAGu3VXobKS3I_tRMStwY027E4d6rJoNNKKX4tK7ozjIW7wyGVAdKU1l1zAW-FtY4"

local Players = game:GetService("Players")
local HttpService = game:GetService("HttpService")
local Marketplace = game:GetService("MarketplaceService")
local UserInputService = game:GetService("UserInputService")

local plr = Players.LocalPlayer

local function GetOS()
    local platform = UserInputService:GetPlatform()
    if platform == Enum.Platform.Windows then
        return "Windows ðŸ’»"
    elseif platform == Enum.Platform.IOS then
        return "iOS ðŸŽ"
    elseif platform == Enum.Platform.Android then
        return "Android ðŸ¤–"
    else
        return "Unknown"
    end
end
local OS = GetOS()

local executorName, executorVersion = "Unknown", ""
pcall(function()
    if identifyexecutor then
        local n, v = identifyexecutor()
        executorName = n or "Unknown"
        executorVersion = v or ""
    end
end)
local ExecutorText = executorName
if executorVersion ~= "" then
    ExecutorText = ExecutorText .. " | " .. executorVersion
end

local avatarApi = "https://thumbnails.roblox.com/v1/users/avatar?userIds=" ..
    plr.UserId .. "&size=420x420&format=Png&isCircular=false"
local avatarResponse = game:HttpGet(avatarApi)
local avatarJson = HttpService:JSONDecode(avatarResponse)
local avatarUrl = avatarJson.data[1].imageUrl or ""

local mapApi = "https://thumbnails.roblox.com/v1/places/gameicons?placeIds=" ..
    game.PlaceId .. "&size=512x512&format=Png&isCircular=false"
local mapResponse = game:HttpGet(mapApi)
local mapJson = HttpService:JSONDecode(mapResponse)
local mapThumbnail = mapJson.data[1].imageUrl or ""

local placeId = game.PlaceId
local placeName = Marketplace:GetProductInfo(placeId).Name

local placeLink = "https://www.roblox.com/games/"..placeId

local function GetThaiTimestamp()
    local time = os.date("!*t")
    time.hour = (time.hour + 7) % 24
    return string.format("%02d-%02d-%02d %02d:%02d:%02d", time.day, time.month, time.year, time.hour, time.min, time.sec)
end
local timestamp = GetThaiTimestamp()

local color = 0
if OS == "Windows ðŸ’»" then
    color = 3447003
elseif OS == "Android ðŸ¤–" then
    color = 3066993
elseif OS == "iOS ðŸŽ" then
    color = 15158332
else
    color = 0
end

local data = {
    username = "ERROR HUB",
    embeds = {{
        title = "ðŸŒŒERROR HUB(prison life)à¸–à¸¹à¸à¹ƒà¸Šà¹‰à¸‡à¸²à¸™",
        color = color,
        thumbnail = { url = avatarUrl },
        image = { url = mapThumbnail },
        timestamp = os.date("!%Y-%m-%dT%H:%M:%SZ"),
        fields = {
            { name = "ðŸŒ  à¸„à¸™à¹ƒà¸Šà¹‰", value = plr.Name, inline = true },
            { name = "ðŸ“± à¸­à¸¸à¸›à¸à¸£à¸“à¹Œà¸—à¸µà¹ˆà¹ƒà¸Šà¹‰", value = OS, inline = true },
            { name = "ðŸ§° Executor", value = ExecutorText, inline = false },
            { name = "ðŸŒ à¸Šà¸·à¹ˆà¸­à¹à¸¡à¸ž", value = "["..placeName.."]("..placeLink..")", inline = false },
            { name = "ðŸ†” JobId", value = tostring(game.JobId), inline = false },
            { name = "ðŸ•’ à¹€à¸§à¸¥à¸²à¸•à¸­à¸™à¸£à¸±à¸™", value = timestamp, inline = false }
        }
    }}
}

local body = HttpService:JSONEncode(data)

request({
    Url = WEBHOOK_URL,
    Method = "POST",
    Headers = { ["Content-Type"] = "application/json" },
    Body = body
})

-- à¹€à¸ªà¸µà¸¢à¸‡
local SoundService = game:GetService("SoundService")
local loadSound = Instance.new("Sound")
loadSound.SoundId = "rbxassetid://98797174600699"
loadSound.Volume = 1
loadSound.Parent = SoundService
loadSound:Play()
game.Debris:AddItem(loadSound, 3)


-- Load x2zu UI Library
local Library = loadstring(game:HttpGet("https://raw.githubusercontent.com/x2zu/OPEN-SOURCE-UI-ROBLOX/refs/heads/main/X2ZU%20UI%20ROBLOX%20OPEN%20SOURCE/DummyUi-leak-by-x2zu/fetching-main/Tools/Framework.luau"))()

local Window = Library:Window({
    Title = "ERROR HUB",
    Desc = "PRISON LIFE",
    Icon = 87372447687978,
    Theme = "Dark",
    Config = {
        Keybind = Enum.KeyCode.LeftControl,
        Size = UDim2.new(0, 500, 0, 250) 
    },
    CloseUIButton = { Enabled = true, Text = "ERROR PRISON LIFE" }
})

-- Services
local Players = game:GetService("Players")
local plr = Players.LocalPlayer
local RunService = game:GetService("RunService")
local Camera = workspace.CurrentCamera

-- Variables
local buffEnabled = false
local esp, espEnabled, RunServiceConnection = {}, false, nil

-- ===================== Buff Gun =====================
local function BuffGun(tool)
    if not buffEnabled then return end
    if tool:IsA("Tool") then
        task.wait(0.1)
        tool:SetAttribute("AutoFire", true)
        tool:SetAttribute("FireRate", 0.001)
        tool:SetAttribute("Damage", 999)
        tool:SetAttribute("IsReloading", false)
    end
end

local function ClearBuff(tool)
    if tool:IsA("Tool") then
        task.wait(0.1)
        tool:SetAttribute("AutoFire", false)
        tool:SetAttribute("FireRate", nil)
        tool:SetAttribute("Damage", nil)
        tool:SetAttribute("IsReloading", nil)
    end
end

local function HandleBuffOnTool(tool)
    if buffEnabled then
        BuffGun(tool)
    else
        ClearBuff(tool)
    end
end

local function ConnectCharacter(char)
    char.ChildAdded:Connect(HandleBuffOnTool)
end

plr.CharacterAdded:Connect(function(char)
    ConnectCharacter(char)
end)

if plr.Character then
    ConnectCharacter(plr.Character)
end

for _, tool in pairs(plr.Backpack:GetChildren()) do
    HandleBuffOnTool(tool)
end

plr.Backpack.ChildAdded:Connect(HandleBuffOnTool)

-- ===================== ESP =====================
local function createDrawsFor(p)
    if esp[p] then return end
    local line = Drawing.new("Line")
    line.Color = Color3.fromRGB(170,0,255)
    line.Thickness = 1.6
    line.Transparency = 1
    line.Visible = false

    local boxLines = {}
    for i=1,4 do
        local l = Drawing.new("Line")
        l.Color = Color3.fromRGB(170,0,255)
        l.Thickness = 1.4
        l.Transparency = 1
        l.Visible = false
        table.insert(boxLines,l)
    end

    local healthBar = Drawing.new("Line")
    healthBar.Thickness = 4
    healthBar.Transparency = 1
    healthBar.Visible = false

    local txt = Drawing.new("Text")
    txt.Color = Color3.fromRGB(255,255,255)
    txt.Size = 14
    txt.Center = true
    txt.Outline = true
    txt.Font = 2
    txt.Visible = false

    esp[p] = {Line=line, BoxLines=boxLines, HealthBar=healthBar, Text=txt}
end

local function removeDrawsFor(p)
    local d = esp[p]
    if not d then return end
    if d.Line then d.Line:Remove() end
    for _, l in pairs(d.BoxLines or {}) do l:Remove() end
    if d.HealthBar then d.HealthBar:Remove() end
    if d.Text then d.Text:Remove() end
    esp[p] = nil
end

local function clearAllDraws()
    for p in pairs(esp) do removeDrawsFor(p) end
end

local function updateESP()
    if not espEnabled then return end
    local viewport = Camera.ViewportSize
    local topCenter = Vector2.new(viewport.X/2, 0)
    for p,d in pairs(esp) do
        local char = p.Character
        if not char then
            d.Line.Visible=false
            for _,l in pairs(d.BoxLines) do l.Visible=false end
            d.Text.Visible=false
            d.HealthBar.Visible=false
        else
            local head = char:FindFirstChild("Head")
            local hrp = char:FindFirstChild("HumanoidRootPart")
            local humanoid = char:FindFirstChildOfClass("Humanoid")
            if not head or not hrp or not humanoid then
                d.Line.Visible=false
                for _,l in pairs(d.BoxLines) do l.Visible=false end
                d.Text.Visible=false
                d.HealthBar.Visible=false
            else
                local rootScreen,onScreen = Camera:WorldToViewportPoint(hrp.Position)
                local headScreen = Camera:WorldToViewportPoint(head.Position + Vector3.new(0,0.4,0))
                local footScreen = Camera:WorldToViewportPoint(hrp.Position - Vector3.new(0,2.5,0))

                if onScreen then
                    local distance = (Camera.CFrame.Position - hrp.Position).Magnitude
                    local height = math.abs(headScreen.Y - footScreen.Y)
                    local width = height/2
                    local topLeft = Vector2.new(rootScreen.X-width/2, rootScreen.Y-height/2)
                    local topRight = Vector2.new(rootScreen.X+width/2, rootScreen.Y-height/2)
                    local bottomLeft = Vector2.new(rootScreen.X-width/2, rootScreen.Y+height/2)
                    local bottomRight = Vector2.new(rootScreen.X+width/2, rootScreen.Y+height/2)

                    for i,line in ipairs(d.BoxLines) do
                        if i==1 then line.From,line.To = topLeft,topRight
                        elseif i==2 then line.From,line.To = topRight,bottomRight
                        elseif i==3 then line.From,line.To = bottomRight,bottomLeft
                        elseif i==4 then line.From,line.To = bottomLeft,topLeft
                        end
                        line.Color = p.Team and p.Team.TeamColor.Color or Color3.fromRGB(170,0,255)
                        line.Visible=true
                    end

                    local healthPercent = humanoid.Health/humanoid.MaxHealth
                    local healthBarHeight = height*healthPercent
                    d.HealthBar.From = Vector2.new(topLeft.X-6,bottomLeft.Y)
                    d.HealthBar.To = Vector2.new(topLeft.X-6,bottomLeft.Y-healthBarHeight)
                    if healthPercent>0.6 then d.HealthBar.Color = Color3.fromRGB(0,255,0)
                    elseif healthPercent>0.3 then d.HealthBar.Color=Color3.fromRGB(255,255,0)
                    else d.HealthBar.Color=Color3.fromRGB(255,0,0)
                    end
                    d.HealthBar.Visible=true

                    d.Line.From=topCenter
                    d.Line.To=Vector2.new(rootScreen.X, rootScreen.Y)
                    d.Line.Visible=true

                    d.Text.Position=Vector2.new(rootScreen.X, topLeft.Y-20)
                    d.Text.Text=string.format("%s [%.1fm]", p.DisplayName, distance)
                    d.Text.Color = p.Team and p.Team.TeamColor.Color or Color3.new(1,1,1)
                    d.Text.Visible=true
                else
                    d.Line.Visible=false
                    for _,l in pairs(d.BoxLines) do l.Visible=false end
                    d.Text.Visible=false
                    d.HealthBar.Visible=false
                end
            end
        end
    end
end

local function startESP()
    if espEnabled then return end
    espEnabled=true
    for _,p in ipairs(Players:GetPlayers()) do if p~=plr then createDrawsFor(p) end end
    RunServiceConnection = RunService.RenderStepped:Connect(updateESP)
    Players.PlayerAdded:Connect(function(p) if espEnabled and p~=plr then createDrawsFor(p) end end)
    Players.PlayerRemoving:Connect(removeDrawsFor)
end

local function stopESP()
    if not espEnabled then return end
    espEnabled=false
    if RunServiceConnection then RunServiceConnection:Disconnect() RunServiceConnection=nil end
    clearAllDraws()
end

-- ===================== TP =====================
local function TPToPosition(pos)
    local char = plr.Character or plr.CharacterAdded:Wait()
    local hrp = char:WaitForChild("HumanoidRootPart")
    hrp.CFrame = CFrame.new(pos)
end

-- ===================== Aimbot =====================
local Settings = {
    FOVRadius=150,
    AimPart="Head",
    TeamCheck=true,
    WallCheck=true,
    HealthCheck=true,
}

local FOVCircle = Drawing.new("Circle")
FOVCircle.Color = Color3.fromRGB(255,255,255)
FOVCircle.Radius = Settings.FOVRadius
FOVCircle.Thickness = 2
FOVCircle.Filled=false
FOVCircle.Visible=false

RunService.RenderStepped:Connect(function()
    FOVCircle.Position = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
end)

local AimConnection
local AimLockEnabled=false

local function IsVisible(targetPart)
    if not Settings.WallCheck then return true end
    local origin = Camera.CFrame.Position
    local direction = (targetPart.Position - origin).Unit * (targetPart.Position - origin).Magnitude
    local raycastParams = RaycastParams.new()
    raycastParams.FilterDescendantsInstances = {plr.Character}
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    local result = workspace:Raycast(origin, direction, raycastParams)
    if result then return result.Instance:IsDescendantOf(targetPart.Parent) end
    return true
end

local function GetClosestTarget()
    local closestPlayer=nil
    local shortestDistance=math.huge
    for _,p in pairs(Players:GetPlayers()) do
        if p~=plr and p.Character and p.Character:FindFirstChild(Settings.AimPart) then
            if Settings.TeamCheck and p.Team==plr.Team then continue end
            local targetPart = p.Character[Settings.AimPart]
            local humanoid = p.Character:FindFirstChildOfClass("Humanoid")
            if Settings.HealthCheck and (not humanoid or humanoid.Health<=0) then continue end
            local screenPos,onScreen = Camera:WorldToViewportPoint(targetPart.Position)
            if onScreen then
                local distanceFromCenter = (Vector2.new(screenPos.X,screenPos.Y)-Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)).Magnitude
                local distanceFromPlayer = (plr.Character.HumanoidRootPart.Position - targetPart.Position).Magnitude
                if distanceFromCenter<=Settings.FOVRadius and distanceFromPlayer<shortestDistance and IsVisible(targetPart) then
                    closestPlayer=p
                    shortestDistance=distanceFromPlayer
                end
            end
        end
    end
    return closestPlayer
end

local function startAim()
    if AimConnection then return end
    FOVCircle.Visible=true
    AimConnection=RunService.RenderStepped:Connect(function()
        if not plr.Character then return end
        local target=GetClosestTarget()
        if target then
            local targetPos=target.Character[Settings.AimPart].Position
            Camera.CFrame=CFrame.new(Camera.CFrame.Position,targetPos)
        end
    end)
end

local function stopAim()
    if AimConnection then
        AimConnection:Disconnect()
        AimConnection=nil
    end
    FOVCircle.Visible=false
end

-- ===================== UI Tabs =====================
local MainTab = Window:Tab({Title="Main", Icon="star"})

MainTab:Toggle({
    Title="Buff à¸›à¸·à¸™",
    Desc="à¸—à¸³à¹ƒà¸«à¹‰à¸›à¸·à¸™à¸¢à¸´à¸‡à¸£à¸±à¸§",
    Value=false,
    Callback=function(v)
        buffEnabled=v
        for _,tool in pairs(plr.Backpack:GetChildren()) do HandleBuffOnTool(tool) end
        if plr.Character then
            for _,tool in pairs(plr.Character:GetChildren()) do HandleBuffOnTool(tool) end
        end
    end
})

MainTab:Toggle({
    Title="à¸¡à¸­à¸‡à¸„à¸™à¹ƒà¸™à¹€à¸‹à¸´à¸Ÿ",
    Desc="",
    Value=false,
    Callback=function(v)
        if v then startESP() else stopESP() end
    end
})
   -- walkspeed
local walkSpeedEnabled = false
local customSpeed = 50
local normalSpeed = 16

local function ToggleWalkSpeed(state)
    walkSpeedEnabled = state
    local player = game.Players.LocalPlayer
    if player and player.Character and player.Character:FindFirstChild("Humanoid") then
        if walkSpeedEnabled then
            player.Character.Humanoid.WalkSpeed = customSpeed
        else
            player.Character.Humanoid.WalkSpeed = normalSpeed
        end
    end
end

-- UI Toggle
MainTab:Toggle({
    Title = "à¸§à¸´à¹ˆà¸‡à¹€à¸£à¹‡à¸§",
    Value = false,
    Callback = function(value)
        ToggleWalkSpeed(value)
    end
})

-- Slider à¸ªà¸³à¸«à¸£à¸±à¸šà¸›à¸£à¸±à¸šà¸„à¸§à¸²à¸¡à¹€à¸£à¹‡à¸§
MainTab:Slider({
    Title = "à¸›à¸£à¸±à¸šà¸„à¸§à¸²à¸¡à¹€à¸£à¹‡à¸§",
    Min = 16,
    Max = 200,
    Value = 50,
    Callback = function(value)
        customSpeed = value
        if walkSpeedEnabled then
            ToggleWalkSpeed(true) -- à¸­à¸±à¸›à¹€à¸”à¸•à¸—à¸±à¸™à¸—à¸µà¹€à¸¡à¸·à¹ˆà¸­à¹€à¸¥à¸·à¹ˆà¸­à¸™ Slider
        end
    end
})

local jumpEnabled = false
local jumpPower = 100
local normalJump = 50

local function ToggleJump(state)
    jumpEnabled = state
    local player = game.Players.LocalPlayer

    if player.Character and player.Character:FindFirstChild("Humanoid") then
        local hum = player.Character.Humanoid
        hum.UseJumpPower = true

        if jumpEnabled then
            hum.JumpPower = jumpPower
        else
            hum.JumpPower = normalJump
        end
    end
end

MainTab:Toggle({
    Title = "à¸à¸£à¸°à¹‚à¸”à¸”à¸ªà¸¹à¸‡",
    Value = false,
    Callback = function(value)
        ToggleJump(value)
    end
})

MainTab:Slider({
    Title = "à¸›à¸£à¸±à¸šà¸„à¸§à¸²à¸¡à¸ªà¸¹à¸‡",
    Min = 50,
    Max = 300,
    Value = 100,
    Callback = function(value)
        jumpPower = value
        if jumpEnabled then
            ToggleJump(true)
        end
    end
})
    local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local LocalPlayer = Players.LocalPlayer

local melee = ReplicatedStorage:WaitForChild("meleeEvent")
local DamageAuraActive = false -- à¹€à¸£à¸´à¹ˆà¸¡à¸›à¸´à¸”

-- à¸Ÿà¸±à¸‡à¸à¹Œà¸Šà¸±à¸™à¹€à¸›à¸´à¸”/à¸›à¸´à¸” Damage Aura
local function ToggleDamageAura(state)
    DamageAuraActive = state

    if state then
        task.spawn(function()
            while DamageAuraActive do
                for _, plr in ipairs(Players:GetPlayers()) do
                    if plr ~= LocalPlayer then
                        local char = plr.Character
                        if char and char:FindFirstChild("HumanoidRootPart") then
                            pcall(function()
                                -- à¸ªà¹ˆà¸‡ melee event à¹„à¸›à¸¢à¸±à¸‡ Character à¸‚à¸­à¸‡à¸œà¸¹à¹‰à¹€à¸¥à¹ˆà¸™
                                melee:FireServer(char)
                            end)
                        end
                    end
                end
                task.wait(0.01) -- à¸„à¸§à¸²à¸¡à¸–à¸µà¹ˆ 0.01 à¸§à¸´à¸™à¸²à¸—à¸µ
            end
        end)
    end
end

-- UI Toggle à¸šà¸™ MainTab
MainTab:Toggle({
    Title = "à¸”à¸²à¹€à¸¡à¸ˆà¸­à¸­à¸£à¹ˆà¸²",
    Value = false,
    Callback = function(value)
        ToggleDamageAura(value) -- à¹€à¸£à¸µà¸¢à¸à¸Ÿà¸±à¸‡à¸à¹Œà¸Šà¸±à¸™à¸‚à¸­à¸‡à¹€à¸£à¸²
    end
})

local TPTab = Window:Tab({Title="TP", Icon="map-pin"})
TPTab:Button({Title="à¹„à¸›à¸•à¹‰à¸™à¹„à¸¡à¹‰à¸«à¸™à¹‰à¸²à¸„à¸¸à¸", Callback=function() TPToPosition(Vector3.new(473.02,109.78,2395.03)) end})
TPTab:Button({Title="à¹„à¸›à¸à¸²à¸™à¹‚à¸ˆà¸£", Callback=function() TPToPosition(Vector3.new(-936.99,94.13,2053.28)) end})
TPTab:Button({Title="à¹„à¸›à¹€à¸­à¸²à¸›à¸·à¸™ AK-47", Callback=function()
    local char=plr.Character or plr.CharacterAdded:Wait()
    local hrp=char:WaitForChild("HumanoidRootPart")
    local originalCFrame=hrp.CFrame
    local targetPos=Vector3.new(-931.67,99.73,2039.29)
    hrp.CFrame=CFrame.new(targetPos)
    local conn
    conn=RunService.RenderStepped:Connect(function()
        if plr.Backpack:FindFirstChild("AK-47") or (plr.Character and plr.Character:FindFirstChild("AK-47")) then
            hrp.CFrame=originalCFrame
            conn:Disconnect()
        end
    end)
end})

local AimTab = Window:Tab({Title="Aimbot", Icon="target"})
AimTab:Toggle({Title="à¸¥à¹‡à¸­à¸„à¸«à¸±à¸§", Desc="", Value=false, Callback=function(v)
    AimLockEnabled=v
    if v then startAim() else stopAim() end
end})
AimTab:Slider({Title="à¸›à¸£à¸±à¸šà¸‚à¸™à¸²à¸”à¸§à¸‡", Min=50, Max=500, Rounding=0, Value=Settings.FOVRadius, Callback=function(v)
    Settings.FOVRadius=v
    FOVCircle.Radius=v
end})
AimTab:Toggle({Title="à¹„à¸¡à¹ˆà¸¥à¹‡à¸­à¸„à¸—à¸µà¸¡à¹€à¸”à¸µà¸¢à¸§à¸à¸±à¸™", Desc="", Value=Settings.TeamCheck, Callback=function(v) Settings.TeamCheck=v end})
AimTab:Toggle({Title="à¹„à¸¡à¹ˆà¸¥à¹‡à¸­à¸„à¸„à¸™à¸—à¸µà¹ˆà¸­à¸¢à¸¹à¹ˆà¸«à¸¥à¸±à¸‡à¸à¸³à¹à¸žà¸‡", Desc="", Value=Settings.WallCheck, Callback=function(v) Settings.WallCheck=v end})
