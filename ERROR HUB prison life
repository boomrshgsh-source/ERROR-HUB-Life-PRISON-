local WEBHOOK_URL = "https://canary.discord.com/api/webhooks/1440700806495080511/GX8AAGu3VXobKS3I_tRMStwY027E4d6rJoNNKKX4tK7ozjIW7wyGVAdKU1l1zAW-FtY4"

local Players = game:GetService("Players")
local HttpService = game:GetService("HttpService")
local Marketplace = game:GetService("MarketplaceService")
local UserInputService = game:GetService("UserInputService")

local plr = Players.LocalPlayer

local function GetOS()
    local platform = UserInputService:GetPlatform()
    if platform == Enum.Platform.Windows then
        return "Windows üíª"
    elseif platform == Enum.Platform.IOS then
        return "iOS üçé"
    elseif platform == Enum.Platform.Android then
        return "Android ü§ñ"
    else
        return "Unknown"
    end
end
local OS = GetOS()

local executorName, executorVersion = "Unknown", ""
pcall(function()
    if identifyexecutor then
        local n, v = identifyexecutor()
        executorName = n or "Unknown"
        executorVersion = v or ""
    end
end)
local ExecutorText = executorName
if executorVersion ~= "" then
    ExecutorText = ExecutorText .. " | " .. executorVersion
end

local avatarApi = "https://thumbnails.roblox.com/v1/users/avatar?userIds=" ..
    plr.UserId .. "&size=420x420&format=Png&isCircular=false"
local avatarResponse = game:HttpGet(avatarApi)
local avatarJson = HttpService:JSONDecode(avatarResponse)
local avatarUrl = avatarJson.data[1].imageUrl or ""

local mapApi = "https://thumbnails.roblox.com/v1/places/gameicons?placeIds=" ..
    game.PlaceId .. "&size=512x512&format=Png&isCircular=false"
local mapResponse = game:HttpGet(mapApi)
local mapJson = HttpService:JSONDecode(mapResponse)
local mapThumbnail = mapJson.data[1].imageUrl or ""

local placeId = game.PlaceId
local placeName = Marketplace:GetProductInfo(placeId).Name

local placeLink = "https://www.roblox.com/games/"..placeId

local function GetThaiTimestamp()
    local time = os.date("!*t")
    time.hour = (time.hour + 7) % 24
    return string.format("%02d-%02d-%02d %02d:%02d:%02d", time.day, time.month, time.year, time.hour, time.min, time.sec)
end
local timestamp = GetThaiTimestamp()

local color = 0
if OS == "Windows üíª" then
    color = 3447003
elseif OS == "Android ü§ñ" then
    color = 3066993
elseif OS == "iOS üçé" then
    color = 15158332
else
    color = 0
end

local data = {
    username = "ERROR HUB",
    embeds = {{
        title = "üååERROR HUB(prison life)‡∏ñ‡∏π‡∏Å‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô",
        color = color,
        thumbnail = { url = avatarUrl },
        image = { url = mapThumbnail },
        timestamp = os.date("!%Y-%m-%dT%H:%M:%SZ"),
        fields = {
            { name = "üå† ‡∏Ñ‡∏ô‡πÉ‡∏ä‡πâ", value = plr.Name, inline = true },
            { name = "üì± ‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ", value = OS, inline = true },
            { name = "üß∞ Executor", value = ExecutorText, inline = false },
            { name = "üåç ‡∏ä‡∏∑‡πà‡∏≠‡πÅ‡∏°‡∏û", value = "["..placeName.."]("..placeLink..")", inline = false },
            { name = "üÜî JobId", value = tostring(game.JobId), inline = false },
            { name = "üïí ‡πÄ‡∏ß‡∏•‡∏≤‡∏ï‡∏≠‡∏ô‡∏£‡∏±‡∏ô", value = timestamp, inline = false }
        }
    }}
}

local body = HttpService:JSONEncode(data)

request({
    Url = WEBHOOK_URL,
    Method = "POST",
    Headers = { ["Content-Type"] = "application/json" },
    Body = body
})

-- ‡πÄ‡∏™‡∏µ‡∏¢‡∏á
local SoundService = game:GetService("SoundService")
local loadSound = Instance.new("Sound")
loadSound.SoundId = "rbxassetid://98797174600699"
loadSound.Volume = 1
loadSound.Parent = SoundService
loadSound:Play()
game.Debris:AddItem(loadSound, 3)


-- Load x2zu UI Library
local Library = loadstring(game:HttpGet("https://raw.githubusercontent.com/x2zu/OPEN-SOURCE-UI-ROBLOX/refs/heads/main/X2ZU%20UI%20ROBLOX%20OPEN%20SOURCE/DummyUi-leak-by-x2zu/fetching-main/Tools/Framework.luau"))()

local Window = Library:Window({
    Title = "ERROR HUB",
    Desc = "PRISON LIFE",
    Icon = 87372447687978,
    Theme = "Dark",
    Config = {
        Keybind = Enum.KeyCode.LeftControl,
        Size = UDim2.new(0, 500, 0, 250) 
    },
    CloseUIButton = { Enabled = true, Text = "ERROR PRISON LIFE" }
})

-- Services
local Players = game:GetService("Players")
local plr = Players.LocalPlayer
local RunService = game:GetService("RunService")
local Camera = workspace.CurrentCamera

-- Variables
local buffEnabled = false
local esp, espEnabled, RunServiceConnection = {}, false, nil

-- ===================== Buff Gun =====================
local function BuffGun(tool)
    if not buffEnabled then return end
    if tool:IsA("Tool") then
        task.wait(0.1)
        tool:SetAttribute("AutoFire", true)
        tool:SetAttribute("FireRate", 0.001)
        tool:SetAttribute("Damage", 999)
        tool:SetAttribute("IsReloading", false)
    end
end

local function ClearBuff(tool)
    if tool:IsA("Tool") then
        task.wait(0.1)
        tool:SetAttribute("AutoFire", false)
        tool:SetAttribute("FireRate", nil)
        tool:SetAttribute("Damage", nil)
        tool:SetAttribute("IsReloading", nil)
    end
end

local function HandleBuffOnTool(tool)
    if buffEnabled then
        BuffGun(tool)
    else
        ClearBuff(tool)
    end
end

local function ConnectCharacter(char)
    char.ChildAdded:Connect(HandleBuffOnTool)
end

plr.CharacterAdded:Connect(function(char)
    ConnectCharacter(char)
end)

if plr.Character then
    ConnectCharacter(plr.Character)
end

for _, tool in pairs(plr.Backpack:GetChildren()) do
    HandleBuffOnTool(tool)
end

plr.Backpack.ChildAdded:Connect(HandleBuffOnTool)

-- ===================== ESP =====================
local function createDrawsFor(p)
    if esp[p] then return end
    local line = Drawing.new("Line")
    line.Color = Color3.fromRGB(170,0,255)
    line.Thickness = 1.6
    line.Transparency = 1
    line.Visible = false

    local boxLines = {}
    for i=1,4 do
        local l = Drawing.new("Line")
        l.Color = Color3.fromRGB(170,0,255)
        l.Thickness = 1.4
        l.Transparency = 1
        l.Visible = false
        table.insert(boxLines,l)
    end

    local healthBar = Drawing.new("Line")
    healthBar.Thickness = 4
    healthBar.Transparency = 1
    healthBar.Visible = false

    local txt = Drawing.new("Text")
    txt.Color = Color3.fromRGB(255,255,255)
    txt.Size = 14
    txt.Center = true
    txt.Outline = true
    txt.Font = 2
    txt.Visible = false

    esp[p] = {Line=line, BoxLines=boxLines, HealthBar=healthBar, Text=txt}
end

local function removeDrawsFor(p)
    local d = esp[p]
    if not d then return end
    if d.Line then d.Line:Remove() end
    for _, l in pairs(d.BoxLines or {}) do l:Remove() end
    if d.HealthBar then d.HealthBar:Remove() end
    if d.Text then d.Text:Remove() end
    esp[p] = nil
end

local function clearAllDraws()
    for p in pairs(esp) do removeDrawsFor(p) end
end

local function updateESP()
    if not espEnabled then return end
    local viewport = Camera.ViewportSize
    local topCenter = Vector2.new(viewport.X/2, 0)
    for p,d in pairs(esp) do
        local char = p.Character
        if not char then
            d.Line.Visible=false
            for _,l in pairs(d.BoxLines) do l.Visible=false end
            d.Text.Visible=false
            d.HealthBar.Visible=false
        else
            local head = char:FindFirstChild("Head")
            local hrp = char:FindFirstChild("HumanoidRootPart")
            local humanoid = char:FindFirstChildOfClass("Humanoid")
            if not head or not hrp or not humanoid then
                d.Line.Visible=false
                for _,l in pairs(d.BoxLines) do l.Visible=false end
                d.Text.Visible=false
                d.HealthBar.Visible=false
            else
                local rootScreen,onScreen = Camera:WorldToViewportPoint(hrp.Position)
                local headScreen = Camera:WorldToViewportPoint(head.Position + Vector3.new(0,0.4,0))
                local footScreen = Camera:WorldToViewportPoint(hrp.Position - Vector3.new(0,2.5,0))

                if onScreen then
                    local distance = (Camera.CFrame.Position - hrp.Position).Magnitude
                    local height = math.abs(headScreen.Y - footScreen.Y)
                    local width = height/2
                    local topLeft = Vector2.new(rootScreen.X-width/2, rootScreen.Y-height/2)
                    local topRight = Vector2.new(rootScreen.X+width/2, rootScreen.Y-height/2)
                    local bottomLeft = Vector2.new(rootScreen.X-width/2, rootScreen.Y+height/2)
                    local bottomRight = Vector2.new(rootScreen.X+width/2, rootScreen.Y+height/2)

                    for i,line in ipairs(d.BoxLines) do
                        if i==1 then line.From,line.To = topLeft,topRight
                        elseif i==2 then line.From,line.To = topRight,bottomRight
                        elseif i==3 then line.From,line.To = bottomRight,bottomLeft
                        elseif i==4 then line.From,line.To = bottomLeft,topLeft
                        end
                        line.Color = p.Team and p.Team.TeamColor.Color or Color3.fromRGB(170,0,255)
                        line.Visible=true
                    end

                    local healthPercent = humanoid.Health/humanoid.MaxHealth
                    local healthBarHeight = height*healthPercent
                    d.HealthBar.From = Vector2.new(topLeft.X-6,bottomLeft.Y)
                    d.HealthBar.To = Vector2.new(topLeft.X-6,bottomLeft.Y-healthBarHeight)
                    if healthPercent>0.6 then d.HealthBar.Color = Color3.fromRGB(0,255,0)
                    elseif healthPercent>0.3 then d.HealthBar.Color=Color3.fromRGB(255,255,0)
                    else d.HealthBar.Color=Color3.fromRGB(255,0,0)
                    end
                    d.HealthBar.Visible=true

                    d.Line.From=topCenter
                    d.Line.To=Vector2.new(rootScreen.X, rootScreen.Y)
                    d.Line.Visible=true

                    d.Text.Position=Vector2.new(rootScreen.X, topLeft.Y-20)
                    d.Text.Text=string.format("%s [%.1fm]", p.DisplayName, distance)
                    d.Text.Color = p.Team and p.Team.TeamColor.Color or Color3.new(1,1,1)
                    d.Text.Visible=true
                else
                    d.Line.Visible=false
                    for _,l in pairs(d.BoxLines) do l.Visible=false end
                    d.Text.Visible=false
                    d.HealthBar.Visible=false
                end
            end
        end
    end
end

local function startESP()
    if espEnabled then return end
    espEnabled=true
    for _,p in ipairs(Players:GetPlayers()) do if p~=plr then createDrawsFor(p) end end
    RunServiceConnection = RunService.RenderStepped:Connect(updateESP)
    Players.PlayerAdded:Connect(function(p) if espEnabled and p~=plr then createDrawsFor(p) end end)
    Players.PlayerRemoving:Connect(removeDrawsFor)
end

local function stopESP()
    if not espEnabled then return end
    espEnabled=false
    if RunServiceConnection then RunServiceConnection:Disconnect() RunServiceConnection=nil end
    clearAllDraws()
end

-- ===================== TP =====================
local function TPToPosition(pos)
    local char = plr.Character or plr.CharacterAdded:Wait()
    local hrp = char:WaitForChild("HumanoidRootPart")
    hrp.CFrame = CFrame.new(pos)
end

-- ===================== Aimbot =====================
local Settings = {
    FOVRadius=150,
    AimPart="Head",
    TeamCheck=true,
    WallCheck=true,
    HealthCheck=true,
}

local FOVCircle = Drawing.new("Circle")
FOVCircle.Color = Color3.fromRGB(255,255,255)
FOVCircle.Radius = Settings.FOVRadius
FOVCircle.Thickness = 2
FOVCircle.Filled=false
FOVCircle.Visible=false

RunService.RenderStepped:Connect(function()
    FOVCircle.Position = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
end)

local AimConnection
local AimLockEnabled=false

local function IsVisible(targetPart)
    if not Settings.WallCheck then return true end
    local origin = Camera.CFrame.Position
    local direction = (targetPart.Position - origin).Unit * (targetPart.Position - origin).Magnitude
    local raycastParams = RaycastParams.new()
    raycastParams.FilterDescendantsInstances = {plr.Character}
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    local result = workspace:Raycast(origin, direction, raycastParams)
    if result then return result.Instance:IsDescendantOf(targetPart.Parent) end
    return true
end

local function GetClosestTarget()
    local closestPlayer=nil
    local shortestDistance=math.huge
    for _,p in pairs(Players:GetPlayers()) do
        if p~=plr and p.Character and p.Character:FindFirstChild(Settings.AimPart) then
            if Settings.TeamCheck and p.Team==plr.Team then continue end
            local targetPart = p.Character[Settings.AimPart]
            local humanoid = p.Character:FindFirstChildOfClass("Humanoid")
            if Settings.HealthCheck and (not humanoid or humanoid.Health<=0) then continue end
            local screenPos,onScreen = Camera:WorldToViewportPoint(targetPart.Position)
            if onScreen then
                local distanceFromCenter = (Vector2.new(screenPos.X,screenPos.Y)-Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)).Magnitude
                local distanceFromPlayer = (plr.Character.HumanoidRootPart.Position - targetPart.Position).Magnitude
                if distanceFromCenter<=Settings.FOVRadius and distanceFromPlayer<shortestDistance and IsVisible(targetPart) then
                    closestPlayer=p
                    shortestDistance=distanceFromPlayer
                end
            end
        end
    end
    return closestPlayer
end

local function startAim()
    if AimConnection then return end
    FOVCircle.Visible=true
    AimConnection=RunService.RenderStepped:Connect(function()
        if not plr.Character then return end
        local target=GetClosestTarget()
        if target then
            local targetPos=target.Character[Settings.AimPart].Position
            Camera.CFrame=CFrame.new(Camera.CFrame.Position,targetPos)
        end
    end)
end

local function stopAim()
    if AimConnection then
        AimConnection:Disconnect()
        AimConnection=nil
    end
    FOVCircle.Visible=false
end

-- ===================== UI Tabs =====================
local MainTab = Window:Tab({Title="Main", Icon="star"})

MainTab:Toggle({
    Title="Buff ‡∏õ‡∏∑‡∏ô",
    Desc="‡∏ó‡∏≥‡πÉ‡∏´‡πâ‡∏õ‡∏∑‡∏ô‡∏¢‡∏¥‡∏á‡∏£‡∏±‡∏ß",
    Value=false,
    Callback=function(v)
        buffEnabled=v
        for _,tool in pairs(plr.Backpack:GetChildren()) do HandleBuffOnTool(tool) end
        if plr.Character then
            for _,tool in pairs(plr.Character:GetChildren()) do HandleBuffOnTool(tool) end
        end
    end
})

MainTab:Toggle({
    Title="‡∏°‡∏≠‡∏á‡∏Ñ‡∏ô‡πÉ‡∏ô‡πÄ‡∏ã‡∏¥‡∏ü",
    Desc="",
    Value=false,
    Callback=function(v)
        if v then startESP() else stopESP() end
    end
})
   -- walkspeed
local walkSpeedEnabled = false
local customSpeed = 50
local normalSpeed = 16

local function ToggleWalkSpeed(state)
    walkSpeedEnabled = state
    local player = game.Players.LocalPlayer
    if player and player.Character and player.Character:FindFirstChild("Humanoid") then
        if walkSpeedEnabled then
            player.Character.Humanoid.WalkSpeed = customSpeed
        else
            player.Character.Humanoid.WalkSpeed = normalSpeed
        end
    end
end

-- UI Toggle
MainTab:Toggle({
    Title = "‡∏ß‡∏¥‡πà‡∏á‡πÄ‡∏£‡πá‡∏ß",
    Value = false,
    Callback = function(value)
        ToggleWalkSpeed(value)
    end
})

-- Slider ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏±‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß
MainTab:Slider({
    Title = "‡∏õ‡∏£‡∏±‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß",
    Min = 16,
    Max = 200,
    Value = 50,
    Callback = function(value)
        customSpeed = value
        if walkSpeedEnabled then
            ToggleWalkSpeed(true) -- ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏ó‡∏±‡∏ô‡∏ó‡∏µ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÄ‡∏•‡∏∑‡πà‡∏≠‡∏ô Slider
        end
    end
})

local jumpEnabled = false
local jumpPower = 100
local normalJump = 50

local function ToggleJump(state)
    jumpEnabled = state
    local player = game.Players.LocalPlayer

    if player.Character and player.Character:FindFirstChild("Humanoid") then
        local hum = player.Character.Humanoid
        hum.UseJumpPower = true

        if jumpEnabled then
            hum.JumpPower = jumpPower
        else
            hum.JumpPower = normalJump
        end
    end
end

MainTab:Toggle({
    Title = "‡∏Å‡∏£‡∏∞‡πÇ‡∏î‡∏î‡∏™‡∏π‡∏á",
    Value = false,
    Callback = function(value)
        ToggleJump(value)
    end
})

MainTab:Slider({
    Title = "‡∏õ‡∏£‡∏±‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏π‡∏á",
    Min = 50,
    Max = 300,
    Value = 100,
    Callback = function(value)
        jumpPower = value
        if jumpEnabled then
            ToggleJump(true)
        end
    end
})
    local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local melee = ReplicatedStorage:WaitForChild("meleeEvent")
local LocalPlayer = Players.LocalPlayer

local DamageAuraActive = false

-- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÄ‡∏õ‡∏¥‡∏î/‡∏õ‡∏¥‡∏î Damage Aura
local function ToggleDamageAura(state)
    DamageAuraActive = state
    if state then
        task.spawn(function()
            while DamageAuraActive do
                -- ‡∏£‡∏≠‡πÉ‡∏´‡πâ‡∏ï‡∏±‡∏ß‡πÄ‡∏≠‡∏á‡∏°‡∏µ‡∏ï‡∏±‡∏ß‡∏•‡∏∞‡∏Ñ‡∏£‡πÅ‡∏•‡∏∞‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏ï‡∏≤‡∏¢
                if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") and LocalPlayer.Character.Humanoid.Health > 0 then
                    for _, plr in ipairs(Players:GetPlayers()) do
                        if plr ~= LocalPlayer then
                            local char = plr.Character
                            if char and char:FindFirstChild("Humanoid") then
                                pcall(function()
                                    melee:FireServer(plr)
                                end)
                            end
                        end
                    end
                end
                task.wait(0.2)
            end
        end)
    end
end

-- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ä‡πà‡∏ß‡∏¢‡πÉ‡∏´‡πâ Damage Aura ‡∏¢‡∏¥‡∏á‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô respawn
local function setupRespawnListener(player)
    player.CharacterAdded:Connect(function(char)
        -- ‡∏ï‡∏±‡∏ß loop ‡∏´‡∏•‡∏±‡∏Å‡∏à‡∏∞‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÄ‡∏≠‡∏á‡∏ó‡∏∏‡∏Å 0.01 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ
        -- ‡πÄ‡∏£‡∏≤‡πÅ‡∏Ñ‡πà‡∏£‡∏≠‡πÉ‡∏´‡πâ Character ‡πÇ‡∏´‡∏•‡∏î‡πÄ‡∏™‡∏£‡πá‡∏à
        task.wait(0.1)
    end)
end

-- ‡∏ï‡∏±‡πâ‡∏á listener ‡πÉ‡∏´‡πâ‡∏ó‡∏∏‡∏Å‡∏Ñ‡∏ô‡πÉ‡∏ô‡πÄ‡∏Å‡∏°
for _, plr in ipairs(Players:GetPlayers()) do
    setupRespawnListener(plr)
end

-- listener ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡πÉ‡∏´‡∏°‡πà‡∏ó‡∏µ‡πà‡πÄ‡∏Ç‡πâ‡∏≤‡∏°‡∏≤
Players.PlayerAdded:Connect(function(plr)
    setupRespawnListener(plr)
end)

-- listener ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö respawn ‡∏ï‡∏±‡∏ß‡πÄ‡∏≠‡∏á
LocalPlayer.CharacterAdded:Connect(function(char)
    if DamageAuraActive then
        task.wait(0.1)
        ToggleDamageAura(true)
    end
end)

-- ‡πÄ‡∏û‡∏¥‡πà‡∏° toggle ‡πÉ‡∏ô MainTab
MainTab:Toggle({
    Title = "‡∏î‡∏≤‡πÄ‡∏°‡∏à‡∏≠‡∏≠‡∏£‡πà‡∏≤",
    Value = false,
    Callback = function(value)
        ToggleDamageAura(value)
    end
})
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

local antiTaseActive = false

local function applyAntiTase()
    local gunRemotes = ReplicatedStorage:FindFirstChild("GunRemotes")
    if not gunRemotes then return end

    local playerTased = gunRemotes:FindFirstChild("PlayerTased")
    if playerTased then
        -- Remote ‡∏´‡∏•‡∏≠‡∏Å
        local fakeEvent = playerTased:Clone()
        fakeEvent.Parent = gunRemotes

        playerTased:Destroy()
    end
end

LocalPlayer.CharacterAdded:Connect(function()
    if antiTaseActive then
        task.wait(0.5)
        applyAntiTase()
    end
end)

MainTab:Toggle({
    Title = "üõ°Ô∏è Anti‚ÄëTase",
    Value = false,
    Callback = function(value)
        antiTaseActive = value
        if antiTaseActive then
            applyAntiTase()
        end
    end
})

local TPTab = Window:Tab({Title="TP", Icon="map-pin"})
TPTab:Button({Title="‡πÑ‡∏õ‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡∏´‡∏ô‡πâ‡∏≤‡∏Ñ‡∏∏‡∏Å", Callback=function() TPToPosition(Vector3.new(473.02,109.78,2395.03)) end})
TPTab:Button({Title="‡πÑ‡∏õ‡∏ê‡∏≤‡∏ô‡πÇ‡∏à‡∏£", Callback=function() TPToPosition(Vector3.new(-936.99,94.13,2053.28)) end})
TPTab:Button({Title="‡πÑ‡∏õ‡πÄ‡∏≠‡∏≤‡∏õ‡∏∑‡∏ô AK-47", Callback=function()
    local char=plr.Character or plr.CharacterAdded:Wait()
    local hrp=char:WaitForChild("HumanoidRootPart")
    local originalCFrame=hrp.CFrame
    local targetPos=Vector3.new(-931.67,99.73,2039.29)
    hrp.CFrame=CFrame.new(targetPos)
    local conn
    conn=RunService.RenderStepped:Connect(function()
        if plr.Backpack:FindFirstChild("AK-47") or (plr.Character and plr.Character:FindFirstChild("AK-47")) then
            hrp.CFrame=originalCFrame
            conn:Disconnect()
        end
    end)
end})

local AimTab = Window:Tab({Title="Aimbot", Icon="target"})
AimTab:Toggle({Title="‡∏•‡πá‡∏≠‡∏Ñ‡∏´‡∏±‡∏ß", Desc="", Value=false, Callback=function(v)
    AimLockEnabled=v
    if v then startAim() else stopAim() end
end})
AimTab:Slider({Title="‡∏õ‡∏£‡∏±‡∏ö‡∏Ç‡∏ô‡∏≤‡∏î‡∏ß‡∏á", Min=50, Max=500, Rounding=0, Value=Settings.FOVRadius, Callback=function(v)
    Settings.FOVRadius=v
    FOVCircle.Radius=v
end})
AimTab:Toggle({Title="‡πÑ‡∏°‡πà‡∏•‡πá‡∏≠‡∏Ñ‡∏ó‡∏µ‡∏°‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏Å‡∏±‡∏ô", Desc="", Value=Settings.TeamCheck, Callback=function(v) Settings.TeamCheck=v end})
AimTab:Toggle({Title="‡πÑ‡∏°‡πà‡∏•‡πá‡∏≠‡∏Ñ‡∏Ñ‡∏ô‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡∏´‡∏•‡∏±‡∏á‡∏Å‡∏≥‡πÅ‡∏û‡∏á", Desc="", Value=Settings.WallCheck, Callback=function(v) Settings.WallCheck=v end})
